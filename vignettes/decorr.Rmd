---
title: "Graph and Spatial Analysis of Iconography for Prehistory"
author: "Thomas Huet, Jose Pozo, Craig Alexander"
email: "thomashuet7@gmail.com"
date: "`r format(Sys.Date())`"
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Graph and Spatial Analysis of Iconography for Prehistory}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  
references:
- id: Huet18
  title: Geometric graphs to study ceramic decoration
  author:
  - family: Huet
    given: Thomas
  container-title: Proceedings of the 44th Conference on Computer Applications and Quantitative Methods in Archaeology, CAA 2016
  publisher: Archaeopress
  page: 311-324
  type: article-journal
  URL: 'https://www.researchgate.net/publication/343514122_Geometric_graphs_to_study_ceramic_decoration'
  issued:
    year: 2018
    
- id: HuetAlexander15
  title: "Méthodes informatiques pour l’étude des gravures rupestres : les exemples du Valcamonica (Italie) et du mont Bego (France)"
  author:
  - family: Huet
    given: Thomas
  - family: Alexander
    given: Craig
  container-title: "Recherches sur l'âge du Bronze, Nouvelles approches et perspectives, Actes de la journée d'étude de l'Association pour la promotion des recherches archéologiques sur l'âge du Bronze, 28 février 2014, Saint-Germain-en-Laye"
  publisher: "Bulletin de l'APRAB, suppl. n° 1"
  page: 15-29
  type: article-journal
  issued:
    year: 2015

- id: Alexander08
  title: The Bedolina map -- an exploratory network analysis
  author:
  - family: Alexander
    given: Craig
  container-title: Layers of Perception. Proceedings of the 35th International Conference on Computer Applications and Quantitative Methods in Archaeology (CAA),  Berlin, 2.-6. April 2007
  publisher: Koll. Vor- u. Frühgesch
  page: 366-371
  type: article-journal
  doi: 'https://doi.org/10.11588/propylaeumdok.00000512'
  issued:
    year: 2008   

- id: DiazGuardamino10
  title: Las estelas decoradas en la Prehistoria de la Pen{\'\i}nsula Ib{\'e}rica
  author:
  - family: Diaz-Guardamino
    given: Marta
  publisher: Universidad Complutense de Madrid, Servicio de Publicaciones
  type: article-journal
  issued:
    year: 2010 
---

```{r, include = FALSE}
library(knitr)
library(dplyr)
library(kableExtra)
library(igraph)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.pos = 'H'
)
```

# Introduction

The R package `decorr` is used to study iconography with graph theory and spatial analysis indexes.  

Its purpose is to contribute to cross-cultural iconography comparisons studies by a higher normalization of quantitative analysis [@HuetAlexander15]. This package has been grounded on the seminal work of C. Alexander [@Alexander08] and its first IT implementation by T. Huet [@Huet18]. 

The main principle of `decorr` package is to considerate any iconographic compositions (here, 'decorations') as relative neighborhood graphs (RNG) where the nodes are the graphical units (GUs) sharing an edge one with another (edges) when their Voronoi cell share a border. The RNG covers all the GUs, so the decoration is considered as a 1-component graph. Before the analysis process, contemporaneous and non-contemporaneous GUs can be studied separately.   

Buidling decoration graphs in a GIS is already a spatial database of the iconographic content. Furthermore, it facilitate the data recording, with snapping options for example to connect GUs (nodes) with lines (edges), and allows to combine analyses coming from Graph theory and GIS management.  

# Install

Install the `decorr` package from GitHub and load it.  

```{r load_decorr, warning=FALSE}
# devtools::install_github("zoometh/iconr")
library(decorr)
```

## Contents

The R package `decorr` is composed by functions and a dataset example (external data). All the drawings presented here have been first published by M. Diaz-Guardamino [@DiazGuardamino10]

### Functions

Functions are provided to manage nodes (`nds`), edges (`eds`) and graphs (`grph`).

```{r ls_functions}
cat(ls("package:decorr"), sep="\n")
```

### Data

External data give a training dataset to illustrate the package main functions.  

The current path of training external data is the `extdata` folder of the package. Change this working directory for your own directory.

```{r ls_ext_data}
# iconr_path <- "C:/Documents/decorr/inst/extdata/"
iconr_path <- system.file("extdata", package = "decorr")
cat(list.files(iconr_path),sep="\n")
```

Each decoration is a set of:

  + a drawing/image (`.jpg`)
  
  + a dataframe of decoration identifiers (`.tsv` or `.csv`)
  
  + a dataframe of nodes (`.tsv`, `.csv` or `.shp`)
  
  + a dataframe of edges (`.tsv`, `.csv` or `.shp`)
  
Since a GIS interface is often the most practicale to record nodes and edges, the package has been designed to accept shapefiles (`.shp`) for nodes (`POINTS` geometries) and edges (`LINES` geometries). Tabular data can be `.tsv` (tab-separated values) or `.csv` (semicolons-separated values) 


#### Drawings/Images

For a given decoration, its drawing (ie, images, raster, grid) is the space of reference of the graph: nodes and edges inherit their coordinates from the decoration grid. Identifiers and paths to images are stored in the `imgs` dataframe

```{r imgs,fig.width=6, fig.height=6, fig.align="center",warning=FALSE, fig.cap="\\label{fig:figs}imgs.tsv"}
imgs_path <- paste0(iconr_path, "/imgs.tsv")
imgs <- read.table(imgs_path, sep="\t", stringsAsFactors = FALSE)
knitr::kable(imgs, "html") %>% 
  kable_styling(full_width = FALSE, position = "center", font_size=12)
```

The decorations unique identifiers are the concatenation of the site name and decoration name. For example, the name of the `Cerrano Muriano 1` decoration is ``r imgs[1,"img"]``.  

Drawing/images (`.jpg`) are mostly managed with the R [`magick-image` package](https://cran.r-project.org/web/packages/magick/vignettes/intro.html)

```{r drawing,fig.width=6, fig.height=6, fig.align="center", warning=FALSE, echo=FALSE, message=FALSE, fig.cap="\\label{fig:figs}Cerro_Muriano.Cerro_Muriano_1.jpg"}
library(magick)
plot(image_trim(image_read(paste0(iconr_path, "/", imgs[1,"img"]))))
```


Nodes are located approximatively on the centroid of GUs. The R [`igraph` package](https://igraph.org/r/) allow further network analysis. Other spatial analysis can be performed on a GIS.

#### Nodes

Nodes (ie, vertices) are stored in a dataframe (`.csv` or `.tsv`) or a shapefile (`.shp`). If the input data come from a dataframe, coordinates columns `x` and `y` are required


```{r nodes.df, warning=FALSE,fig.align="center",warning=FALSE}
nds.df <- read_nds(site = "Cerro Muriano", decor = "Cerro Muriano 1", doss = iconr_path) 
knitr::kable(nds.df, "html") %>% 
  kable_styling(full_width = FALSE, position = "center", font_size=12)
```


* column names  
  
  - `site`: decoration site 
  
  - `decor`: decoration name 
  
  - `id`: id of the edges (a unique number) 
    
  - `type`: type of the nodes    
    
  - `x, y`: coordinates of the nodes  
    

#### Edges


Edges are stored in a dataframe (`.csv` or `.tsv`) or a shapefile (`.shp`). If the input data is a dataframe, coordinates columns `xa` and `ya` (origins of the edges), `xb` and `yb` (ends of the edges) are required.  


```{r edges.df, warning=FALSE}
eds.df <- read_eds(site = "Cerro Muriano", decor = "Cerro Muriano 1", doss = iconr_path) 
knitr::kable(eds.df, "html") %>% 
  kable_styling(full_width = FALSE, position = "center", font_size=12)
```


* column names  
  
  - `site`: decoration site 
  
  - `decor`: decoration name  
  
  - `id`: id of the edge (a unique number) 
  
  - `a`: *id* of the first node  
    
  - `b`: *id* of the second node  
    
  - `type`: [Edges types][]  
  
    - `=`: [*normal* edges][] (undirected)  
    
    - `+`: [*attribute* edges][], node `b` is an attribute of node `a` (directed)
    
    - `>`: [*overlap* edges][], node `a` overlaps node `b` (directed)
    
  - `xa, ya`: coordinates of the first node  (`a`) 
    
  - `xb, yb`: coordinates of the second node (`b`) 
  
##### Edges types

By default, all comtemporaneous GUs are linked with edges are displayed in <span style="color:orange"><b>orange</b></span>. At the opposite, GUs coming from different periods are linked with <span style="color:blue"><b>blue</b></span> edges.  

Except the *normal* edges which is undirected, the *attribute* and *overlap* edges are directed. That is to say, that for *attribute* and *overlap* edges `1-*-2`, where `*` could be either `+` or `>`, is not equal to `2-*-1`. 

* *normal* edges

Usually, differents GUs considerated as contemporaneous and close one with another, shared an edge with the  value `=` for their `type`. By convention, these edges are called '*normal*' and displayed with a plain line.

```{r graph.normal.plot.type, fig.width=6, fig.height=6, fig.align="center", warning=FALSE, fig.cap="Brozas decoration, normal edges"}
nds.df <- read_nds(site = "Brozas", 
                   decor = "Brozas",
                   doss = iconr_path)
eds.df <- read_eds(site = "Brozas",
                   decor = "Brozas",
                   doss = iconr_path)
img.graph <- plot_dec_grph(nds.df = nds.df,
                           eds.df = eds.df,
                           site = "Brozas",
                           decor = "Brozas",
                           lbl.txt = "type",
                           lbl.size = 2,
                           shw = c("nodes","edges"),
                           doss = iconr_path)
plot(img.graph)
```

* *attribute* edges

When a GU is an attribute of another, edges are identified with a `+` and displayed with a dashed line.  For example, at the bottom of the `Zarza De Montanchez` decoration, the main GU chariot `7` is connected with four GUs attributes (or secondary GUs):

  - two horses (cheval): `8` and `9`  
  
  - two wheels (roue): `10` and `11` 

```{r graph.attribute.plot.type, fig.width=6, fig.height=6, fig.align="center", warning=FALSE, fig.cap="Zarza De Montanchez decoration, normal and attribute edges"}
nds.df <- read_nds(site = "Zarza de Montanchez", 
                   decor = "Zarza De Montanchez",
                   doss = iconr_path)
eds.df <- read_eds(site = "Zarza de Montanchez",
                   decor = "Zarza De Montanchez",
                   doss = iconr_path)
img.graph <- plot_dec_grph(nds.df = nds.df,
                           eds.df = eds.df,
                           site = "Zarza de Montanchez",
                           decor = "Zarza De Montanchez",
                           lbl.txt = "type",
                           lbl.size = 2,
                           shw = c("nodes","edges"),
                           doss = iconr_path)
plot(img.graph)
```

For example, the edge between the GUs `7` and `8` (respectively the chariot and a horse) is:

```{r plot.a.edge.attribute, fig.width=6, fig.height=6, fig.align="center", warning=FALSE}
eds.df <- read_eds(site = "Zarza de Montanchez", decor = "Zarza De Montanchez", doss = iconr_path)
cat(paste0(eds.df[8,"a"]," -",eds.df[8,"type"],"- ",eds.df[8,"b"]))
```

* *overlap* edges

When a GU overlapping another -- or is more recent than antother -- edges ae identified with a `>` and displayed with a blue plain line. For example, the `Ibahernando` stelae show a latin writing (écriture) overlaping a spear (lance) and a shield (bouclier).
  

```{r graph.overlap.plot.type, fig.width=6, fig.height=6, fig.align="center", warning=FALSE, fig.cap="Ibahernando decoration, normal and overlap edges"}
nds.df <- read_nds(site = "Ibahernando", 
                   decor = "Ibahernando",
                   doss = iconr_path)
eds.df <- read_eds(site = "Ibahernando",
                   decor = "Ibahernando",
                   doss = iconr_path)
img.graph <- plot_dec_grph(nds.df = nds.df,
                           eds.df = eds.df,
                           site = "Ibahernando",
                           decor = "Ibahernando",
                           lbl.txt = "type",
                           lbl.size = 2,
                           shw = c("nodes","edges"),
                           doss = iconr_path)
plot(img.graph)
```

For example, the edge between the GUs `1` and `2` (respectively the writing and the spear) is:

```{r plot.a.edge.overlap, fig.width=6, fig.height=6, fig.align="center", warning=FALSE}
eds.df <- read_eds(site = "Ibahernando", decor = "Ibahernando", doss = iconr_path)
cat(paste0(eds.df[1,"a"]," -",eds.df[1,"type"],"- ",eds.df[1,"b"]))
```

Exists a function to [Remove non-contemporaneous iconographical content][]

## Examples

### Plot decoration graph

Plot `Cerro Muriano 1` nodes and edges for the field `type` with with bigger and <span style="color:DarkOrange">dark orange</span> labels 

```{r img.graph.plot.type, fig.width=6, fig.height=6, fig.align="center", warning=FALSE}
# setwd(system.file("extdata", package = "decorr"))
nds.df <- read_nds(site = "Cerro Muriano", decor = "Cerro Muriano 1", doss = iconr_path)
eds.df <- read_eds(site = "Cerro Muriano", decor = "Cerro Muriano 1", doss = iconr_path)
img.graph <- plot_dec_grph(nds.df = nds.df,
                           eds.df = eds.df,
                           site = "Cerro Muriano",
                           decor = "Cerro Muriano 1",
                           lbl.txt = "type",
                           shw = c("nodes","edges"),
                           lbl.color = "darkorange",
                           lbl.size=2,
                           doss = iconr_path)
plot(img.graph)
```
  
Replot the graph with `id` field instead of the `type` field

```{r img.graph.plot.id, fig.width=6, fig.height=6, fig.align="center", warning=FALSE}
# setwd(system.file("extdata", package = "decorr"))
nds.df <- read_nds(site = "Cerro Muriano", decor = "Cerro Muriano 1", doss = iconr_path)
eds.df <- read_eds(site = "Cerro Muriano", decor = "Cerro Muriano 1", doss = iconr_path)
img.graph <- plot_dec_grph(nds.df = nds.df,
                           eds.df = eds.df,
                           site = "Cerro Muriano",
                           decor = "Cerro Muriano 1",
                           lbl.txt = "id",
                           shw = c("nodes","edges"),
                           lbl.color = "darkorange",
                           lbl.size=2,
                           doss = iconr_path)
plot(img.graph)
```
  
### Compare decoration graphs

Between all the graphs, or between a pair of graphs, nodes and edges can be compared with the functions `same_*` (all the graphs) and `plot_*_compar` (a pair of graphs), where `*` is replaced by `nds` for nodes or `eds` for edges.  
By default, between two decorations, common nodes and edges are in <span style="color:red">red</span>, but their colors -- and other graphical parameters -- can be modified.

#### Common Nodes

A classic study is to count the common nodes between decorations pairwise. The `same_nds()` create a symetrical dataframe where cells show the total number of common nodes by decorations (rows and columns headers). Here it is the `type` of the nodes which is considered.

```{r compare.nodes, warning=FALSE}
imgs_path <- paste0(iconr_path, "/imgs.tsv")
nodes_path <- paste0(iconr_path, "/nodes.tsv")
edges_path <- paste0(iconr_path, "/edges.tsv")
imgs <- read.table(imgs_path, sep="\t", stringsAsFactors = FALSE)
nodes <- read.table(nodes_path, sep="\t", stringsAsFactors = FALSE)
edges <- read.table(edges_path, sep="\t", stringsAsFactors = FALSE)
lgrph <- list_dec(imgs, nodes, edges, "type") # call function
df.same_nodes <- same_nds(lgrph, "type")
knitr::kable(df.same_nodes, row.names = TRUE)
```
  
Here, we read that decorations `2` and `3` have five (5) nodes with the same types (ie, common nodes), and decorations `2` and `4` have five (7) common nodes. To show them, use the  `plot_nds_compar()` function.

```{r compare.2.nodes, out.width = "700px", fig.align="center", warning=FALSE}
# set wd to data folder
# out.img path is only useful to open the output image
dec.to.compare <- c(2, 3, 4)
# out.img <- paste0(iconr_path,"/compar_nds_", dec.to.compare[1],"_",dec.to.compare[2],".png")
# read data
imgs_path <- paste0(iconr_path, "/imgs.tsv")
nodes_path <- paste0(iconr_path, "/nodes.tsv")
edges_path <- paste0(iconr_path, "/edges.tsv")
imgs <- read.table(imgs_path, sep="\t", stringsAsFactors = FALSE)
nodes <- read.table(nodes_path, sep="\t", stringsAsFactors = FALSE)
edges <- read.table(edges_path, sep="\t", stringsAsFactors = FALSE)
lgrph <- list_dec(imgs, nodes, edges, "type") # call function
g.compar <- list_nds_compar(lgrph, var="type")
nds_compar <- plot_nds_compar(g.compar,
                              dec.to.compare,
                              var="type",
                              common.nds.size = 1.5,
                              lbl.size = 0.6,
                              doss = iconr_path)
# open image
knitr::include_graphics(nds_compar) 
```

The function creates an image for each pairwise of stelae, that is to say $\frac{n!}{(n-2)!2!}$ pairwise comparisons, when `n` is the number of compared decoration

#### Common Edges

A not so classic study is to count the common edges between decorations pairwise. The `same_eds()` create another symetrical dataframe where cells show the total number of common edges by decorations (rows and columns headers). Here it is the `type` of the edges which is considered.

```{r compare.edges, warning=FALSE}
imgs_path <- paste0(iconr_path, "/imgs.tsv")
nodes_path <- paste0(iconr_path, "/nodes.tsv")
edges_path <- paste0(iconr_path, "/edges.tsv")
imgs <- read.table(imgs_path, sep="\t", stringsAsFactors = FALSE)
nodes <- read.table(nodes_path, sep="\t", stringsAsFactors = FALSE)
edges <- read.table(edges_path, sep="\t", stringsAsFactors = FALSE)
lgrph <- list_dec(imgs, nodes, edges, "type") # call function
df.same_edges <- same_eds(lgrph,"type")
knitr::kable(df.same_edges,row.names = T)
```

Here, we read that  decorations `2` and `3` have three (3) common edges. To show them, use the  `plot_eds_compar()` function.

```{r compare.2.edges, out.width = "700px", fig.align="center", warning=FALSE}
dec.to.compare <- c(2,3)
# out.img <- paste0(iconr_path,"/compar_eds_",dec.to.compare[1],"_",dec.to.compare[2],".png")
# read data
imgs_path <- paste0(iconr_path, "/imgs.tsv")
nodes_path <- paste0(iconr_path, "/nodes.tsv")
edges_path <- paste0(iconr_path, "/edges.tsv")
imgs <- read.table(imgs_path, sep="\t", stringsAsFactors = FALSE)
nodes <- read.table(nodes_path, sep="\t", stringsAsFactors = FALSE)
edges <- read.table(edges_path, sep="\t", stringsAsFactors = FALSE)
lgrph <- list_dec(imgs, nodes, edges, "type") # call function
g.compar <- list_eds_compar(lgrph,var="type")
eds_compar <- plot_eds_compar(g.compar,
                              dec.to.compare,
                              var="type",
                              lbl.size = .6,
                              doss = iconr_path)
# open image
knitr::include_graphics(eds_compar) 
```

#### Remove non-contemporaneous iconographical content

It occurs that some GUs are non-contemporaneous one with the others, like for the latin writing overlapping Late Bronze Age engravings on Ibaherando stelae (see [*overlap* edges][]). In this case, the non-contemporaneous layers of decoration can be removed before the comparison processes by removing `>` edges and selecting the graph component having a selected GU. For example, if we want to study the Late Bronze Age iconographic layer of Ibahernando stelae, we can choose the Late Bronze Age GU numbered 3

```{r rm.writing, out.width = "700px", fig.align="center", warning=FALSE}
selected.nd <- 3
nds.df <- read_nds(site = "Ibahernando", 
                   decor = "Ibahernando",
                   doss = iconr_path)
eds.df <- read_eds(site = "Ibahernando",
                   decor = "Ibahernando",
                   doss = iconr_path)
l_dec_df <- read_nds_contemp(nds.df, eds.df, selected.nd)
Ibahernando.contemp <- plot_dec_grph(nds.df = l_dec_df[[1]],
                           eds.df = l_dec_df[[2]],
                           site = "Ibahernando",
                           decor = "Ibahernando",
                           lbl.txt = "type",
                           shw = c("nodes","edges"),
                           lbl.color = "darkorange",
                           lbl.size=2,
                           doss = iconr_path)
Ibahernando <- plot_dec_grph(nds.df = nds.df,
                           eds.df = eds.df,
                           site = "Ibahernando",
                           decor = "Ibahernando",
                           lbl.txt = "type",
                           shw = c("nodes","edges"),
                           lbl.color = "darkorange",
                           lbl.size=2,
                           doss = iconr_path)
image_append(c(Ibahernando.contemp, Ibahernando))
```

# References


